<?php

	/*
		Тестовое задание для PHP программиста
		Написать функцию, реализующую бинарный поиск значения по ключу в текстовом файле.
		Аргументы: имя файла, значение ключа
		Результат: если найдено: значение, соответствующее ключу, если не найдено: undef
		Исходные данные и требования к реализации:
		1. Объем используемой памяти не должен зависеть от размера файла, только от максимального размера записи.
		2. Формат файла: ключ1\tзначение1\x0Aключ2\tзначение2\x0A...ключN\tзначениеN\x0A Где: \x0A - разделитель записей
			(код ASCII: 0Ah) \t - разделитель ключа и значения (табуляция, код ASCII: 09h) Символы разделителей гарантированно
			не могут встречаться в ключах или значениях. Записи упорядочены по ключу в лексикографическом порядке с учетом
			регистра. Все ключи гарантированно уникальные.
		3. Ограничений на длину ключа или значения нет.
		Функция на файле размером 10Гб с записями длиной до 4000 байт должна отрабатывать любой запрос менее чем за 5 секунд.
	*/

	define('ROOT', dirname(__FILE__)); //определяем константу для корневой дирректории

	function binarySearchByKey( $file, $search_val ){
		$text = fopen( $file, "r" ); //открываем файл для чтения
		while ( !feof($text) ) 
		{ // пока не наступит конец файла
			$string = fgets( $text, 4000 ); // читаем данные по 4000 байт
			mb_convert_encoding($string, 'cp1251'); // чтобы русские буквы не выглядели как кракозябры
			$exploded_string = explode('\x0A', $string); // получается массив ключ\tзначение
			array_pop($exploded_string); // удаляем последний элемент массива т.к. он получается пустым
			foreach ($exploded_string as $key => $value) {
				$arr[] = explode('\t', $value);// получаем массив в массиве, где ключ и значение отдельные элементы
			}
			$start = 0; // задаем начальное значение
			$end = count($arr)-1; // определяем конец. т.к. нулевой массив считается первым элементом вычитываем единицу

			while ($start <= $end) { // цикл работает пока начальное значение не превышает или не становится равным конечной
				$geted_midle = floor(($start + $end) / 2); // определяем середину и округляем сразу же
				$strnatcmp = strnatcmp($arr[$geted_midle][0],$search_val); // сравниваем полученное с искомым

				if ($strnatcmp > 0) {
					$end = $geted_midle - 1; // присваиваем к конечному значению
				} elseif ($strnatcmp < 0) {
					$start = $geted_midle + 1; // присваиваем к начальному значению
				} else {
					return $arr[$geted_midle][1]; // возвращаем значение по ключу
				}
			}
		}
		return 'undef'; // в случаем если в файле вообще нет искомого значения
	}


	$search_val = 'ключ64'; // дальше наверно всё понятно
	$file = ROOT.'/keynumeric.txt'; // используемый файл для тестирования работы
	echo binarySearchByKey($file, $search_val)."</br>";
	echo "Если искомый ключ не существует в файле: ";
	$search_val = 'ключ322';
	echo binarySearchByKey($file, $search_val)."</br>";